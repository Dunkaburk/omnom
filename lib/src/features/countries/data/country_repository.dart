import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:omnom/src/features/countries/domain/country.dart';
import 'package:omnom/src/features/meals/domain/meal.dart';
import 'package:omnom/src/features/meals/domain/meal_comment.dart';

class CountryRepository {
  final FirebaseFirestore _firestore;
  final String _collectionPath = 'countries';
  final String _mealsSubcollectionPath = 'meals';
  final String _commentsSubcollectionPath = 'comments';

  CountryRepository(this._firestore);

  // Get a stream of all countries
  Stream<List<Country>> getCountriesStream() {
    return _firestore.collection(_collectionPath).snapshots().map((snapshot) {
      return snapshot.docs.map((doc) => Country.fromFirestore(doc, doc.id)).toList();
    });
  }

  // Get a stream of a single country's details
  Stream<Country> getCountryDetailsStream(String countryId) {
    return _firestore
        .collection(_collectionPath)
        .doc(countryId)
        .snapshots()
        .map((doc) {
      if (!doc.exists) {
        throw Exception('Country with ID $countryId not found');
      }
      return Country.fromFirestore(doc, doc.id);
    });
  }

  // Get a stream of meals for a specific country
  Stream<List<Meal>> getMealsForCountryStream(String countryId) {
    return _firestore
        .collection(_collectionPath)
        .doc(countryId)
        .collection(_mealsSubcollectionPath)
        .orderBy('date', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) => Meal.fromFirestore(doc)).toList();
    });
  }

  // Add a new country
  Future<void> addCountry(Country country) async {
    try {
      // Let Firestore auto-generate the ID if country.id is empty or not set
      // Or, if your Country model expects an ID to be always present (e.g., generated by Uuid before calling addCountry)
      // then ensure country.id has a value.
      // For now, assuming ID might be handled by Firestore if not provided, or you set it before calling.
      DocumentReference docRef = _firestore.collection(_collectionPath).doc(country.id.isNotEmpty ? country.id : null);
      await docRef.set(country.toFirestore(docRef.id));
    } catch (e) {
      print('Error adding country: $e');
      rethrow;
    }
  }

  // Helper to add initial set of countries if the collection is empty
  // This is useful for development and first-time setup.
  Future<void> addInitialCountries(List<Country> initialCountries) async {
    final WriteBatch batch = _firestore.batch();
    final QuerySnapshot existingCountriesSnapshot = await _firestore.collection(_collectionPath).get();
    final Set<String> existingCountryNames = existingCountriesSnapshot.docs.map((doc) => (doc.data() as Map<String, dynamic>)['name'] as String).toSet();

    for (final country in initialCountries) {
      if (!existingCountryNames.contains(country.name)) {
        DocumentReference docRef = _firestore.collection(_collectionPath).doc(); // Firestore generates ID
        batch.set(docRef, country.toFirestore(docRef.id));
        print('Batching add for new country: ${country.name}');
      }
    }
    try {
      await batch.commit();
      print('Initial countries batch commit successful (if any new were added).');
    } catch (e) {
      print('Error committing initial countries batch: $e');
      // Not rethrowing here as it's part of initial setup, app can often continue.
    }
  }

  // If you need to update a country (e.g., its general fields, not dishes specifically)
  Future<void> updateCountry(Country country) async {
    try {
      await _firestore
          .collection(_collectionPath)
          .doc(country.id)
          .update(country.toFirestore(country.id)); // Assuming toFirestore can handle existing ID
    } catch (e) {
      print('Error updating country ${country.id}: $e');
      rethrow;
    }
  }

  // New method to add a meal to a country's subcollection
  Future<void> addMealToCountry(String countryId, Meal meal) async {
    try {
      if (meal.id.isEmpty) {
        // This should not happen if Meal object always has an ID (e.g. from UUID)
        throw Exception('Meal ID cannot be empty when adding to a country subcollection.');
      }
      await _firestore
          .collection(_collectionPath) // 'countries'
          .doc(countryId)
          .collection(_mealsSubcollectionPath) // 'meals'
          .doc(meal.id) // Use the pre-generated meal.id from the Meal object
          .set(meal.toFirestore());
    } catch (e) {
      print('Error adding meal to country $countryId: ${e.toString()}');
      rethrow;
    }
  }

  // New method to get a single meal from a country's subcollection
  Stream<Meal> getMealFromCountryStream({required String countryId, required String mealId}) {
    return _firestore
        .collection(_collectionPath) // 'countries'
        .doc(countryId)
        .collection(_mealsSubcollectionPath) // 'meals'
        .doc(mealId)
        .snapshots()
        .map((doc) {
      if (!doc.exists) {
        throw Exception('Meal with ID $mealId not found in country $countryId');
      }
      return Meal.fromFirestore(doc);
    });
  }

  // New method to get comments for a specific meal within a country
  Stream<List<MealComment>> getMealCommentsFromCountryStream({required String countryId, required String mealId}) {
    return _firestore
        .collection(_collectionPath)
        .doc(countryId)
        .collection(_mealsSubcollectionPath)
        .doc(mealId)
        .collection(_commentsSubcollectionPath) // 'comments'
        .orderBy('timestamp', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs
          .map((doc) => MealComment.fromFirestore(doc, doc.id))
          .toList();
    });
  }

  // New method to add a comment to a specific meal within a country
  Future<void> addCommentToCountryMeal({required String countryId, required String mealId, required MealComment comment}) async {
    try {
      await _firestore
          .collection(_collectionPath)
          .doc(countryId)
          .collection(_mealsSubcollectionPath)
          .doc(mealId)
          .collection(_commentsSubcollectionPath)
          .add(comment.toFirestore()); // Firestore generates comment ID
    } catch (e) {
      print('Error adding comment to meal $mealId in country $countryId: ${e.toString()}');
      rethrow;
    }
  }
}

// Provider for the CountryRepository
final countryRepositoryProvider = Provider<CountryRepository>((ref) {
  return CountryRepository(FirebaseFirestore.instance);
}); 